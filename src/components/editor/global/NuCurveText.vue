<template lang="pug">
  p(class="nu-curve-text__p" :style="pStyle")
    span(v-if="focus"  class="nu-curve-text__circle" :style="circleStyle")
      svg-icon(iconName="curve-center" :style="curveIconStyle")
    span(v-for="(span, sIndex) in spans"
      class="nu-curve-text__span"
      :class="`nu-curve-text__span-p${pageIndex}l${layerIndex}s${subLayerIndex ? subLayerIndex : -1}`"
      :data-text="span.text"
      :key="sIndex",
      :style="styles(span.styles, sIndex)") {{ span.text }}
</template>

<script lang="ts">
import Vue from 'vue'
import { mapGetters, mapState } from 'vuex'
import TextShapeUtils from '@/utils/textShapeUtils'
import { ISpan } from '@/interfaces/layer'
import tiptapUtils from '@/utils/tiptapUtils'
import LayerUtils from '@/utils/layerUtils'
import TextUtils from '@/utils/textUtils'

export default Vue.extend({
  props: {
    config: Object,
    layerIndex: Number,
    pageIndex: Number,
    subLayerIndex: Number
  },
  data () {
    return {
      textWidth: [] as number[],
      textHeight: [] as number[],
      minHeight: 0,
      isDestroyed: false,
      resizeObserver: undefined as ResizeObserver | undefined
    }
  },
  created () {
    this.computeDimensions(this.spans)
    // TextUtils.loadAllFonts(this.config, 1)
    TextUtils.loadAllFonts(this.config)
  },
  destroyed() {
    this.isDestroyed = true
    this.resizeObserver && this.resizeObserver.disconnect()
    this.resizeObserver = undefined
  },
  mounted() {
    this.resizeObserver = new (window as any).ResizeObserver(() => {
      if (this.isDestroyed) return

      // console.log('resize')

      if (typeof this.subLayerIndex === 'undefined') {
        LayerUtils.updateLayerStyles(this.pageIndex, this.layerIndex, TextShapeUtils.getCurveTextProps(this.config))
      } else {
        LayerUtils.updateSubLayerStyles(this.pageIndex, this.layerIndex, this.subLayerIndex, TextShapeUtils.getCurveTextProps(this.config))
        TextUtils.updateGroupLayerSize(this.pageIndex, this.layerIndex)
        TextUtils.fixGroupCoordinates(this.pageIndex, this.layerIndex)
      }

      this.computeDimensions(this.spans)
    })
    this.observeAllSpans()
  },
  computed: {
    ...mapState('text', ['fontStore']),
    ...mapGetters({
      scaleRatio: 'getPageScaleRatio'
    }),
    focus(): boolean {
      const { textShape } = this.config.styles
      return textShape.focus
    },
    bend(): number {
      const { textShape } = this.config.styles
      return +textShape.bend
    },
    spans(): ISpan[] {
      return TextShapeUtils.flattenSpans(this.config)
    },
    pStyle(): any {
      const { height, width, scale } = this.config.styles
      return {
        margin: 0,
        height: `${height / scale}px`,
        width: `${width / scale}px`
      }
    },
    circleStyle(): any {
      const { bend, minHeight, scaleRatio } = this
      const borderWidth = `${1 / (scaleRatio * 0.01)}px`
      const style = {} as any
      const radius = 1000 / Math.pow(Math.abs(bend), 0.6)
      if (bend >= 0) {
        style.top = `${minHeight / 2}px`
      } else {
        style.bottom = `${minHeight / 2}px`
      }
      if (bend === 0) {
        style.borderRadius = 0
      }
      return {
        ...style,
        borderWidth,
        height: `${radius * 2}px`,
        width: `${radius * 2}px`
      }
    },
    curveIconStyle(): any {
      const { config: { styles }, scaleRatio } = this
      const size = 13 / (scaleRatio * 0.01)
      return {
        width: `${size / styles.scale}px`,
        height: `${size / styles.scale}px`
      }
    },
    transforms(): string[] {
      return TextShapeUtils.convertTextShape(this.textWidth, this.bend)
    }
  },
  watch: {
    spans: {
      handler(newSpans) {
        this.computeDimensions(newSpans)
        if (this.resizeObserver) {
          this.resizeObserver.disconnect()
          this.observeAllSpans()
        }
      },
      deep: true
    }
  },
  methods: {
    styles(styles: any, idx: number) {
      const { transforms, bend, textHeight, minHeight } = this
      const baseline = `${(minHeight - textHeight[idx]) / 2}px`
      const fontStyles = tiptapUtils.textStylesRaw(styles)
      return Object.assign(
        fontStyles,
        { textIndent: fontStyles['letter-spacing'] || 'initial' },
        { transform: transforms[idx] || 'none' },
        bend >= 0 ? { top: baseline } : { bottom: baseline }
      )
    },
    observeAllSpans() {
      const spans = document.querySelectorAll(`.nu-curve-text__span-p${this.pageIndex}l${this.layerIndex}s${this.subLayerIndex ? this.subLayerIndex : -1}`) as NodeList
      spans.forEach(span => {
        this.resizeObserver && this.resizeObserver.observe(span as Element)
      })
    },
    computeDimensions(spans: ISpan[]) {
      const { textWidth, textHeight, minHeight } = TextShapeUtils.getTextHWsBySpans(spans)
      this.textWidth = textWidth
      this.textHeight = textHeight
      this.minHeight = minHeight
    }
  }
})
</script>

<style lang="scss">
.nu-curve-text {
  &__p {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }
  &__circle {
    border: 1px solid rgba(212, 9, 70, 0.5);
    border-radius: 50%;
    position: absolute;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  &__span {
    text-align: left;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    letter-spacing: 0.1px;
    line-height: 1;
    position: absolute;
    display: inline-block;
  }
}
</style>
