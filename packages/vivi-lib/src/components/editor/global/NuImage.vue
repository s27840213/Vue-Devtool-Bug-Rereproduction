<template lang="pug">
div(v-if="!config.imgControl || forRender || isBgImgControl" class="nu-image"
  :class="{ 'nu-image__shadow-container': shadowSrc || showCanvas}"
  :id="`nu-image-${config.id}`"
  :style="containerStyles"
  :cy-ready="cyReady"
  draggable="false")
  div(v-if="showCanvas"
    class="shadow__canvas-wrapper"
    :style="canvasWrapperStyle")
    canvas(ref="canvas" :class="`shadow__canvas_${pageIndex}_${layerIndex}_${typeof subLayerIndex === 'undefined' ? -1 : subLayerIndex}`")
  div(v-if="shadowSrc && !config.isFrameImg"
    :id="inPreview ? '' : `nu-image-${config.id}__shadow`"
    class="shadow__picture"
    :style="imgShadowStyles")
    img(ref="shadow-img"
      class="nu-image__picture-shadow"
      draggable="false"
      :src="shadowSrc"
      @load='onLoadShadowImg($event)'
      @error="onShadowError()")
  div(:class="{'nu-image__clipper': !imgControl}")
    div(class='nu-image__picture'
      :style="imgStyles()")
      img(v-if="finalSrc" ref="img"
        :data-nu-image="`nu-image-${config.id}`"
        :style="flipStyles"
        class="nu-image__img full-size"
        :class="{'layer-flip': flippedAnimation() }"
        draggable="false"
        :crossorigin="userId !== 'backendRendering' ? 'anonymous' : undefined"
        @error="onError"
        @load="onLoad($event, 'main')"
        :src="finalSrc")
      svg(v-if="isAdjustImage && (!forRender || !$isTouchDevice())"
        :style="flipStyles"
        class="nu-image__svg"
        :class="{'layer-flip': flippedAnimation() }"
        :viewBox="`0 0 ${imgNaturalSize.width} ${imgNaturalSize.height}`"
        preserveAspectRatio="none"
        role="image")
        defs
          filter(v-if="!isCurrLayerPinched" :id="filterId"
            color-interpolation-filters="sRGB")
            component(v-for="(elm, idx) in svgFilterElms()"
              :key="`${filterId + idx}`"
              :is="elm.tag"
              v-bind="elm.attrs")
              component(v-for="child in elm.child"
                :key="child.tag"
                :is="child.tag"
                v-bind="child.attrs")
        image(v-if="finalSrc" ref="adjust-img"
          :filter="`url(#${filterId})`"
          :width="imgNaturalSize.width"
          :height="imgNaturalSize.height"
          class="nu-image__img full-size"
          :crossorigin="userId !== 'backendRendering' ? 'anonymous' : undefined"
          draggable="false"
          @error="onError"
          @load="onAdjustImgLoad($event, 'main')"
          :xlink:href="finalSrc")
  template(v-if="hasHalation()")
    component(v-for="(elm, idx) in cssFilterElms()"
      class="nu-image__adjust"
      :key="`cssFilter${idx}`"
      :is="elm.tag"
      v-bind="elm.attrs")
</template>

<script lang="ts">
import i18n from '@/i18n'
import { IShadowEffects, IShadowProps, ShadowEffectType } from '@/interfaces/imgShadow'
import { IFrame, IGroup, IImage, IImageStyle, ILayerIdentifier } from '@/interfaces/layer'
import { IPage } from '@/interfaces/page'
import { IShadowAsset, IUploadShadowImg } from '@/store/module/shadow'
import { IBrowserInfo } from '@/store/module/user'
import { FunctionPanelType, ILayerInfo, LayerProcessType, LayerType } from '@/store/types'
import bgRemoveUtils from '@/utils/bgRemoveUtils'
import frameUtils from '@/utils/frameUtils'
import generalUtils from '@/utils/generalUtils'
import groupUtils from '@/utils/groupUtils'
import imageAdjustUtil from '@/utils/imageAdjustUtil'
import imageShadowPanelUtils from '@/utils/imageShadowPanelUtils'
import imageShadowUtils, { CANVAS_MAX_SIZE, CANVAS_SIZE, CANVAS_SPACE } from '@/utils/imageShadowUtils'
import imageUtils from '@/utils/imageUtils'
import layerUtils from '@/utils/layerUtils'
import logUtils from '@/utils/logUtils'
import modalUtils from '@/utils/modalUtils'
import pageUtils from '@/utils/pageUtils'
import stkWVUtils from '@/utils/stkWVUtils'
import vuexUtils from '@/utils/vuexUtils'
import { notify } from '@kyvg/vue3-notification'
import { AxiosError } from 'axios'
import { PropType, defineComponent } from 'vue'
import { mapActions, mapGetters, mapMutations, mapState } from 'vuex'
import NuAdjustImage from './NuAdjustImage.vue'

export default defineComponent({
  emits: ['onload'],
  props: {
    config: {
      type: Object,
      required: true
    },
    pageIndex: {
      type: Number,
      required: true
    },
    page: {
      type: Object as PropType<IPage>,
      required: true
    },
    layerIndex: {
      type: Number,
      required: true
    },
    subLayerIndex: {
      type: Number,
      default: -1
    },
    isBgImgControl: {
      type: Boolean,
      default: false
    },
    imgControl: {
      type: Boolean,
      default: false
    },
    contentScaleRatio: {
      default: 1,
      type: Number
    },
    /** This prop is used to present if this image-component is
     *  only used for rendering as image controlling */
    forRender: Boolean,
    primaryLayer: {
      type: Object,
      default: () => { return undefined }
    },
    prePrimaryLayerIndex: {
      type: Number,
      default: -1
    },
    inPreview: {
      default: false,
      type: Boolean
    }
  },
  async created() {
    this.handleInitLoad()
    const isPrimaryLayerFrame = layerUtils.getCurrLayer.type === LayerType.frame
    if (!this.config.isFrameImg && !this.isBgImgControl && !this.config.isFrame && !this.config.forRender && !isPrimaryLayerFrame) {
      this.handleShadowInit()
    }
  },
  mounted() {
    if (!this.$isStk) return
    const config = this.config as IImage
    /**
     * bcz bg removing saving place has benn changed
     * the below code is used to update old version design to new version
     */
    //  const srcObj = {
    //             type: 'ios',
    //             userId: '',
    //             assetId: path,
    //           }
    const { assetId, type } = config.srcObj

    if (stkWVUtils.checkVersion('1.35')) {
      if (type === 'ios' && (assetId as string).includes('bgRemove')) {
        const imageName = (assetId as string).split('/')[1]
        const src = imageUtils.getSrc(config.srcObj)

        generalUtils.toDataURL(src, (dataUrl) => {
          bgRemoveUtils.moveOldBgRemoveImages(dataUrl, (path) => {
            stkWVUtils.deleteImage('bgRemove', imageName, 'png')

            layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, {
              srcObj: {
                type: 'ios',
                userId: '',
                assetId: path
              },
            })

            stkWVUtils.saveAsMyDesign()
          })
        })
      }
    }
  },
  beforeUnmount() {
    if (!this.isBgImgControl) {
      if (this.config.inProcess) {
        this.setIsProcessing(LayerProcessType.none)
      }
    }
  },
  unmounted() {
    this.hasDestroyed = true
  },
  data() {
    return {
      hasDestroyed: false,
      isOnError: false,
      src: '',
      errorSrcIdentifier: { identifier: '', retry: 0 },
      shadowBuff: {
        canvasShadowImg: undefined as undefined | HTMLImageElement,
        canvasSize: { width: 0, height: 0 },
        drawCanvasW: 0,
        drawCanvasH: 0,
        MAXSIZE: 0
      },
      imgNaturalSize: {
        width: 0,
        height: 0
      },
      initialized: false,
      isShadowImgLoaded: false
    }
  },
  watch: {
    getImgDimension(newVal, oldVal) {
      this.handleDimensionUpdate(newVal, oldVal)
    },
    'config.srcObj': {
      handler: function (val, oldVal) {
        if (generalUtils.isWatcherTriggerByUndoRedo(val, oldVal)) return

        this.shadowBuff.canvasShadowImg = undefined
        if (this.forRender) {
          return
        }
        this.previewAsLoading()
          .then((img) => {
            const _oldIsTransparent = (this.config as IImage).styles.shadow.isTransparent
            const isTransparent = this.handleIsTransparent(img)
            const redrawImmediately = ![ShadowEffectType.none, ShadowEffectType.floating].includes(this.currentShadowEffect()) &&
              (this.currentShadowEffect() === ShadowEffectType.imageMatched || this.shadow().isTransparent || isTransparent || _oldIsTransparent)
            if (redrawImmediately) {
              this.redrawShadow()
            }
          })
      },
      deep: true
    },
    'config.styles.shadow.effects': {
      handler: function (val, oldVal) {
        if (generalUtils.isWatcherTriggerByUndoRedo(val, oldVal)) return

        const shadow = (this.config as IImage).styles.shadow
        if (shadow.old && shadow.old.currentEffect !== shadow.currentEffect) {
          return
        }
        if (!this.forRender && this.$refs.canvas && !this.isUploadingShadowImg && this.currentShadowEffect() !== ShadowEffectType.none) {
          this.updateShadowEffect(val)
        }
      },
      deep: true
    },
    'config.styles.shadow.currentEffect'() {
      if (this.forRender || this.shadow().srcObj.type === 'upload' || this.getCurrFunctionPanelType !== FunctionPanelType.photoShadow) return
      if (this.$refs.canvas) {
        this.handleNewShadowEffect()
      } else {
        /** until the canvas is mounted */
        setTimeout(() => this.handleNewShadowEffect(), 0)
      }
    },
    showCanvas(val) {
      if (val) {
        setTimeout(() => {
          this.handleNewShadowEffect(false)
        })
      }
    },
    'config.imgControl'(val) {
      if (val) {
        const { subLayerIdx } = this.layerInfo()
        const isSubLayer = typeof subLayerIdx !== 'undefined' && subLayerIdx !== -1
        const currLayer = this.primaryLayer ? this.primaryLayer : this.config
        const isInFrame = isSubLayer && currLayer.type === LayerType.frame && (currLayer as IFrame).clips[subLayerIdx || 0].type === LayerType.image
        const isInGroup = isSubLayer && currLayer.type === LayerType.group && (currLayer as IGroup).layers[subLayerIdx || 0].type === LayerType.image
        if ((!isSubLayer && currLayer.type === LayerType.image) || isInFrame || isInGroup) {
          this.setImgConfig(this.layerInfo())
        }
      } else {
        // groupUtils.deselect()
        this.setImgConfig(undefined)
        // this.$nextTick(() => {
        //   const reSelecting = () => {
        //     const isSubLayer = this.subLayerIndex !== -1 && typeof this.subLayerIndex !== 'undefined'
        //     const targetIdx = isSubLayer ? ((this.config as IImage).parentLayerStyles?.zindex ?? 0) - 1 : this.config.styles.zindex - 1
        //     groupUtils.deselect()
        //     groupUtils.select(this.pageIndex, [targetIdx])
        //     if (isSubLayer) {
        //       const { pageIndex, layerIndex, subLayerIdx } = this.layerInfo()
        //       if (this.primaryLayerType() === LayerType.group) {
        //         layerUtils.updateLayerProps(pageIndex, layerIndex, { active: true }, subLayerIdx)
        //       } else if (this.primaryLayerType() === LayerType.frame) {
        //         frameUtils.updateFrameLayerProps(pageIndex, layerIndex, subLayerIdx ?? 0, { active: true })
        //       }
        //     }
        //   }
        //   if (layerUtils.layerIndex === -1 && !this.isDuringCopy) {
        //     reSelecting()
        //   }
        //   if (this.isDuringCopy) {
        //     const start = Date.now()
        //     const timer = setInterval(() => {
        //       if (Date.now() - start > 10000) {
        //         clearInterval(timer)
        //       }
        //       if (!this.isDuringCopy) {
        //         reSelecting()
        //         clearInterval(timer)
        //       }
        //     }, 300)
        //   }
        // })
        // this.handleDimensionUpdate()
      }
      if (this.forRender) {
        return
      }
      if (!this.config.imgControl && this.currentShadowEffect() !== ShadowEffectType.none) {
        if (this.shadow().isTransparent && ![ShadowEffectType.floating].includes(this.currentShadowEffect())) {
          this.redrawShadow()
        } else if (this.currentShadowEffect() === ShadowEffectType.imageMatched) {
          this.redrawShadow()
        }
      }
    },
    'config.styles.shadow.srcObj': {
      handler: function (val, oldVal) {
        if (generalUtils.isWatcherTriggerByUndoRedo(val, oldVal)) return
        if (!this.config.isFrameImg && val.type === '' && !this.config.forRender) {
          imageShadowUtils.setEffect(this.shadow().currentEffect, {}, this.layerInfo())
        }
        this.handleUploadShadowImg()
        this.isShadowImgLoaded = false
      },
      deep: true
    },
    uploadShadowImgs: {
      handler(val: Array<IUploadShadowImg>) {
        const latest = val[val.length - 1]
        const shadow = this.shadow()
        if (shadow.srcObj.type === 'upload' && latest.id === shadow.srcObj.assetId) {
          const { pageIndex, layerIndex, subLayerIndex: subLayerIdx } = this
          const srcObj = latest.srcObj
          const shadowImgStyles = latest.styles
          imageShadowUtils.updateShadowSrc({ pageIndex, layerIndex, subLayerIdx }, srcObj)
          imageShadowUtils.updateShadowStyles({ pageIndex, layerIndex, subLayerIdx }, shadowImgStyles)
        }
      },
      deep: true
    },
    isBlurImg(val) {
      const { imgWidth, imgHeight } = this.config.styles
      const newSize = val ? imageUtils.getSrcSize(this.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension
      const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, newSize))
      imageUtils.imgLoadHandler(src, () => {
        // bcz this is an async operation, need to check if isBlurImg is the same val
        if (this.isBlurImg === val) {
          this.src = src
        }
      }, {
        crossOrigin: true,
        error: () => {
          if (this.config.srcObj.type === 'private' && newSize === 'xtra') {
            imageUtils.handlePrivateXtraErr(this.config as IImage)
              .then((newSrc) => {
                imageUtils.imgLoadHandler(newSrc, (img) => {
                  this.imgNaturalSize.width = img.width
                  this.imgNaturalSize.height = img.height
                  this.src = newSrc
                })
              })
          }
        }
      })
    }
  },
  components: { NuAdjustImage },
  computed: {
    ...mapGetters({
      pageScaleRatio: 'getPageScaleRatio',
      getCurrFunctionPanelType: 'getCurrFunctionPanelType',
      isUploadingShadowImg: 'shadow/isUploading',
      isHandling: 'shadow/isHandling',
      isShowPagePanel: 'page/getShowPagePanel',
      isProcessing: 'shadow/isProcessing',
      isShowPagePreview: 'page/getIsShowPagePreview',
      controlState: 'getControlState'
    }),
    ...vuexUtils.mapState('stk', {
      isDuringCopy: false,
    },
    'vivisticker',
    {
      isDuringCopy: 'isDuringCopy'
    }),
    ...mapState('user', ['imgSizeMap', 'userId', 'verUni']),
    ...mapState('shadow', ['uploadId', 'handleId', 'uploadShadowImgs']),
    ...mapState('mobileEditor', {
      inAllPagesMode: 'mobileAllPageMode',
    }),
    cyReady(): boolean {
      if (this.src.startsWith('data:image') || // Uploading image, wait for polling, for imageManuallyBgRemove.
        !this.initialized || // Wait for NuImage init, for Image.cy.ts before snapshotTest('init').
        (this.$isTouchDevice() && this.showCanvas) // Wait for mobile shadow process/upload/download/load, for imageShadow command.
      ) return false
      return true
    },
    isCurrLayerPinched(): boolean {
      const { controlState } = this
      if (controlState.layerInfo) {
        return controlState.type === 'pinch' && controlState.layerInfo.pageIndex === this.pageIndex && controlState.layerInfo.layerIndex === this.layerIndex
      } else return false
    },
    isAdjustImage(): boolean {
      const { styles: { adjust = {} } } = this.config
      const arr = Object.entries(adjust).filter(([, v]) => typeof v === 'number' && v !== 0)
      return arr.length !== 0 && !(arr.length === 1 && arr[0][0] === 'halation')
    },
    finalSrc(): string {
      let src = this.src
      if (this.$route.name === 'Preview') {
        return imageUtils.appendCompQueryForVivipic(src)
      }
      if (!this.config.previewSrc) {
        src = imageUtils.appendQuery(src, 'ver', generalUtils.generateRandomString(4))
      }
      return src
    },
    shadowSrc(): string {
      if (!this.shadow() || !this.shadow().srcObj) {
        return ''
      }
      const src = imageUtils.getSrc(this.shadow().srcObj, imageUtils.getSrcSize(this.shadow().srcObj, this.getImgDimension))
      if (this.$route.name === 'Preview') {
        return imageUtils.appendCompQueryForVivipic(src)
      }
      return src
    },
    canvasWrapperStyle(): any {
      if (this.forRender) {
        return {}
      }
      const { scale, horizontalFlip, verticalFlip } = this.config.styles
      const { width, height } = this.shadowBuff.canvasSize
      const _f = this.contentScaleRatio * (generalUtils.isTouchDevice() ? this.pageScaleRatio * 0.01 : 1)

      return {
        width: `${width * _f}px`,
        height: `${height * _f}px`,
        transform: `scaleX(${horizontalFlip ? -1 : 1}) scaleY(${verticalFlip ? -1 : 1}) scale(${scale})`
      }
    },
    imgShadowStyles(): any {
      if (this.forRender) {
        return {}
      }
      const { imgWidth, imgHeight, imgX, imgY } = this.shadow().styles
      const { scale, horizontalFlip, verticalFlip } = this.config.styles
      const _f = this.contentScaleRatio * (generalUtils.isTouchDevice() ? this.pageScaleRatio * 0.01 : 1)
      const xFactor = (horizontalFlip ? -1 : 1) * _f
      const yFactor = (verticalFlip ? -1 : 1) * _f
      return {
        width: (imgWidth * _f).toString() + 'px',
        height: (imgHeight * _f).toString() + 'px',
        transform: `translate(${xFactor * imgX * scale}px, ${yFactor * imgY * scale}px) scaleX(${horizontalFlip ? -1 : 1}) scaleY(${verticalFlip ? -1 : 1}) scale(${scale})`
      }
    },
    flipStyles(): any {
      const { horizontalFlip, verticalFlip } = this.config.styles
      let scaleX = horizontalFlip ? -1 : 1
      let scaleY = verticalFlip ? -1 : 1

      if (typeof this.subLayerIndex !== 'undefined' && this.subLayerIndex !== -1) {
        const primaryLayer = this.primaryLayer ? this.primaryLayer : this.config
        if (primaryLayer.type === 'frame' && this.config.srcObj.type === 'frame') {
          scaleX = primaryLayer.styles.horizontalFlip ? -1 : 1
          scaleY = primaryLayer.styles.verticalFlip ? -1 : 1
        }
      }
      if (scaleX !== 1 || scaleY !== 1) {
        return {
          transform: `scale(${scaleX}, ${scaleY})`
        }
      }
      return {}
    },
    filterId(): string {
      const browserInfo = this.$store.getters['user/getBrowserInfo'] as IBrowserInfo
      const browserIsSafari = browserInfo.name === 'Safari' && browserInfo.version !== '16.3' && generalUtils.versionCheck({ greaterThan: '16.0', lessThan: '16.3' })
      const osIsIos = browserInfo.os.family === 'iOS' && browserInfo.os.version !== '16.3' && generalUtils.versionCheck({ greaterThan: '16.0', lessThan: '16.3', version: browserInfo.os.version })
      if (browserIsSafari || osIsIos) {
        const { styles: { adjust }, id: layerId } = this.config
        const { blur = 0, brightness = 0, contrast = 0, halation = 0, hue = 0, saturate = 0, warm = 0 } = adjust
        const id = layerId + blur.toString() + brightness.toString() + contrast.toString() + halation.toString() + hue.toString() + saturate.toString() + warm.toString()
        return `filter__${id}`
      } else {
        const randomId = generalUtils.generateRandomString(5)
        return `filter__${randomId}`
      }
    },
    showCanvas(): boolean {
      const { subLayerIndex, handleId } = this
      if (this.page === undefined) {
        return false
      }
      const currentShadowEffect = (this.config as IImage).styles.shadow.currentEffect
      const isCurrShadowEffectApplied = currentShadowEffect !== ShadowEffectType.none
      const isHandling = handleId?.pageId === this.page.id && (() => {
        if (subLayerIndex !== -1 && typeof subLayerIndex !== 'undefined') {
          const { primaryLayer = {} } = this
          return primaryLayer.id === handleId.layerId && primaryLayer.layers[subLayerIndex].id === handleId.subLayerId
        } else {
          return this.config.id === handleId.layerId
        }
      })()
      const hasShadowSrc = !!(this.shadow().srcObj && this.shadow().srcObj.type && this.shadow().srcObj.type !== 'upload' && this.shadow().srcObj.assetId)
      return (isCurrShadowEffectApplied && isHandling) || (hasShadowSrc && !this.isShadowImgLoaded)
    },
    containerStyles(): any {
      const { width, height } = this.scaledConfig()
      const styles = {
        // in vivisticker the following code would lead the non-fluent UX
        ...(!this.$isStk && this.isAdjustImage && !this.inAllPagesMode && { transform: 'translateZ(0)' }),
      }
      return this.showCanvas ? {
        ...styles,
        width: `${width}px`,
        height: `${height}px`
      } : {
        ...styles
        // Fix the safari rendering bug, add the following code can fix it...
        // transform: 'translate(0,0)'
      }
    },
    getImgDimension(): number | string {
      const { srcObj } = this.config
      const { imgWidth, imgHeight } = this.config.styles
      let renderW = imgWidth * this.contentScaleRatio
      let renderH = imgHeight * this.contentScaleRatio
      const primaryLayer = this.primaryLayer
      const isPrimaryFrameImg = primaryLayer && primaryLayer.type === LayerType.frame && primaryLayer.clips[0].isFrameImg
      if (!this.forRender && (this.config.parentLayerStyles || primaryLayer) && !isPrimaryFrameImg && srcObj.type !== 'ios') {
        const { scale = 1 } = this.config.parentLayerStyles || primaryLayer?.styles || {}
        renderW *= scale
        renderH *= scale
      }
      const dpiRatio = pageUtils.getImageDpiRatio(this.page)
      renderW *= dpiRatio
      renderH *= dpiRatio
      return imageUtils.getSrcSize(srcObj, imageUtils.getSignificantDimension(renderW, renderH) * (this.pageScaleRatio * 0.01))
    },
    isBlurImg(): boolean {
      return !!this.config.styles.adjust?.blur
    }
  },
  methods: {
    ...mapActions('file', ['updateImages']),
    ...mapActions('brandkit', ['updateLogos']),
    ...mapMutations({
      UPDATE_shadowEffect: 'UPDATE_shadowEffect',
      setIsProcessing: 'bgRemove/SET_isProcessing',
      setImgConfig: 'imgControl/SET_CONFIG'
    }),
    getErrorSrcIdentifier(config: IImage) {
      const { srcObj, styles } = config
      return srcObj.type + srcObj.assetId + srcObj.userId + (styles.adjust.blur > 0 ? '_blur' : '')
    },
    onShadowError() {
      const shadow = this.config.styles.shadow
      if (shadow.srcObj.type === 'ios') {
        const layerData = {
          config: this.config,
          layerInfo: this.layerInfo()
        }
        imageShadowPanelUtils.handleShadowUpload(layerData, true)
      }
    },
    onError() {
      this._onError()
    },
    _onError(imgLoadHandlerError = false) {
      if (!this.src && !imgLoadHandlerError && this.userId !== 'backendRendering') return
      if (this.errorSrcIdentifier.identifier === this.getErrorSrcIdentifier(this.config as IImage)) {
        if (this.errorSrcIdentifier.retry === 3) {
          return
        }
        this.errorSrcIdentifier.retry++
      } else {
        this.errorSrcIdentifier.identifier = this.getErrorSrcIdentifier(this.config as IImage)
        this.errorSrcIdentifier.retry = 1
      }
      const { srcObj, styles: { width, height } } = this.config
      this.isOnError = true
      let updater
      if (imageUtils.getSrcSize(srcObj, Math.max(width, height)) === 'xtra') {
        layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, {
          srcObj: {
            ...srcObj,
            maxSize: 'larg'
          }
        })
        return
      }
      switch (srcObj.type) {
        case 'private':
          updater = async () => await this.updateImages({ assetSet: new Set<string>([srcObj.assetId]) })
          break
        case 'logo-private':
          updater = async () => await this.updateLogos({ assetSet: new Set<string>([srcObj.assetId]) })
          break
        case 'ios': {
          if (this.primaryLayer?.type === LayerType.frame) {
            frameUtils.updateFrameClipSrc(this.pageIndex, this.layerIndex, this.subLayerIndex,
              {
                type: 'frame',
                assetId: '',
                userId: ''
              }
            )
            frameUtils.updateFrameLayerStyles(this.pageIndex, this.layerIndex, this.subLayerIndex, {
              imgWidth: (this.config as IImage).styles.width,
              imgHeight: (this.config as IImage).styles.height,
              imgX: 0,
              imgY: 0,
              opacity: 100,
              adjust: {}
            })
            this.src = imageUtils.getSrc(this.config)
            window.requestAnimationFrame(() => {
              stkWVUtils.isAnyIOSImgOnError = true
              if (this.prePrimaryLayerIndex !== -1) {
                stkWVUtils.setLoadingFlag(this.prePrimaryLayerIndex, this.layerIndex, { k: 'c', v: this.subLayerIndex })
              } else {
                stkWVUtils.setLoadingFlag(this.layerIndex, this.subLayerIndex)
              }
            })
          } else {
            // replace error image
            layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, {
              srcObj: {
                type: 'frame',
                assetId: '',
                userId: ''
              }
            }, this.subLayerIndex)
            layerUtils.updateLayerStyles(this.pageIndex, this.layerIndex, {
              imgWidth: (this.config as IImage).styles.width,
              imgHeight: (this.config as IImage).styles.height,
              imgX: 0,
              imgY: 0,
              opacity: 100,
              adjust: {}
            }, this.subLayerIndex)
            this.src = imageUtils.getSrc(this.config)
          }

          const modalBtn = {
            msg: i18n.global.t('STK0023') as string,
          }
          modalUtils.setModalInfo(i18n.global.t('STK0024') as string, i18n.global.t('STK0086') as string, modalBtn)
        }
      }

      if (updater !== undefined) {
        try {
          updater().then(() => {
            const { imgWidth, imgHeight } = this.config.styles
            const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, this.isBlurImg ? imageUtils.getSrcSize(this.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension))
            imageUtils.imgLoadHandler(src, () => {
              this.src = src
            }, { crossOrigin: true })
          })
        } catch (error) {
          if (this.src.indexOf('data:image/png;base64') !== 0) {
            fetch(this.src)
              .then(res => {
                const { status, statusText } = res
                this.logImgError(error, 'fetch result: ' + status + statusText)
              })
              .catch((e) => {
                this.logImgError(error, 'fetch result: ' + e)
              })
          }
        }
      }
    },
    onAdjustImgLoad(e: Event, type?: string) {
      if (this.$isStk && type === 'main') {
        // detect if SVG image rendered
        const rendering = () => {
          const elImg = this.$refs['adjust-img'] as SVGImageElement
          if (!elImg) return
          if (elImg.width.baseVal.value || elImg.height.baseVal.value) {
            // Render complete
            if (this.prePrimaryLayerIndex !== -1) stkWVUtils.setLoadingFlag(this.prePrimaryLayerIndex, this.layerIndex, { k: 'c', v: this.subLayerIndex })
            else stkWVUtils.setLoadingFlag(this.layerIndex, this.subLayerIndex)
          } else {
            // Rendering
            window.requestAnimationFrame(rendering)
          }
        }
        window.requestAnimationFrame(rendering)
      }
      imageUtils.imgLoadHandler(this.src, (img) => {
        if (this.imgNaturalSize.width !== img.width || this.imgNaturalSize.height !== img.height) {
          this.imgNaturalSize.width = img.width
          this.imgNaturalSize.height = img.height
        }
      }, { crossOrigin: true })
    },
    onLoad(e: Event, type?: string) {
      if (this.$isStk && type === 'main' && !this.isAdjustImage) {
        if (this.prePrimaryLayerIndex !== -1) {
          stkWVUtils.setLoadingFlag(this.prePrimaryLayerIndex, this.layerIndex, { k: 'c', v: this.subLayerIndex })
        } else {
          stkWVUtils.setLoadingFlag(this.layerIndex, this.subLayerIndex)
        }
      }
      this.isOnError = false
      const img = e.target as HTMLImageElement
      if (this.imgNaturalSize.width !== img.width || this.imgNaturalSize.height !== img.height) {
        this.imgNaturalSize.width = img.width
        this.imgNaturalSize.height = img.height
      }
      const physicalRatio = img.naturalWidth / img.naturalHeight
      const layerRatio = this.config.styles.imgWidth / this.config.styles.imgHeight
      if (physicalRatio && layerRatio && Math.abs(physicalRatio - layerRatio) > 0.1 && this.config.srcObj.type !== 'frame') {
        const newW = this.config.styles.imgHeight * physicalRatio
        const offsetW = this.config.styles.imgWidth - newW
        if (this.primaryLayerType() === 'frame') {
          frameUtils.updateFrameLayerStyles(this.pageIndex, this.layerIndex, this.subLayerIndex, {
            imgWidth: newW,
            imgX: this.config.styles.imgX + offsetW / 2
          }, this.prePrimaryLayerIndex)
        } else {
          layerUtils.updateLayerStyles(this.pageIndex, this.layerIndex, {
            imgWidth: newW,
            imgX: this.config.styles.imgX + offsetW / 2
          }, this.subLayerIndex)
        }
      }
      this.$emit('onload')
    },
    onLoadShadowImg(e: Event) {
      setTimeout(() => {
        this.isShadowImgLoaded = true
        // add 10ms to wait for shadow img render.
        // In vvstk, this help prevent screenshot error as shadow img transitioning.
      }, 10)
    },
    logImgError(error: unknown, ...infos: Array<string>) {
      if (this.src.indexOf('data:image/png;base64') !== 0) return

      const { pageIndex, layerIndex, subLayerIndex } = this
      const { srcObj: { type, assetId, userId } } = this.config as IImage
      const e = error as Error | AxiosError
      let log =
        `pageIndex: ${pageIndex}, layerIndex: ${layerIndex}, subLayerIndex: ${subLayerIndex}\n` +
        `srcObj: { type: ${type}, assetId: ${assetId}, userId: ${userId} }\n` +
        `Error config src: ${this.src}`
      infos.forEach(info => { log += `\n${info}` })
      console.warn(log)
      logUtils.setLog(log)
    },
    async previewAsLoading(): Promise<HTMLImageElement | undefined> {
      let isPrimaryImgLoaded = false
      const { imgWidth, imgHeight } = this.config.styles
      const srcSize = this.isBlurImg ? imageUtils.getSrcSize(this.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension
      const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, srcSize))
      const urlId = imageUtils.getImgIdentifier(this.config.srcObj)
      const previewSrc = this.config.previewSrc || imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, this.getPreviewSize()))
      const preImg = await imageUtils.imgLoadHandler<HTMLImageElement | undefined>(previewSrc, (img) => {
        if (imageUtils.getImgIdentifier(this.config.srcObj) === urlId && !isPrimaryImgLoaded) {
          this.src = previewSrc
          return img
        }
      }, { crossOrigin: true })
        .catch(() => {
          // if the previewSrc equals to src, the _onError still need to be called
          if (src === previewSrc) {
            this._onError(true)
          }
          console.warn('img preview cannot be loaded!')
        })

      if (!src || src === previewSrc) return preImg as HTMLImageElement | undefined

      return new Promise<HTMLImageElement>((resolve, reject) => {
        imageUtils.imgLoadHandler(src, (img) => {
          if (imageUtils.getImgIdentifier(this.config.srcObj) === urlId) {
            isPrimaryImgLoaded = true
            this.src = src
            if (this.config.previewSrc === '') {
              layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, { previewSrc: src }, this.subLayerIndex)
            }
            if (!this.isBlurImg) {
              this.preLoadImg('pre', this.getImgDimension)
              this.preLoadImg('next', this.getImgDimension)
            }
            resolve(img)
          }
        }, {
          error: () => {
            if (this.config.srcObj.type === 'private' && srcSize === 'xtra') {
              imageUtils.handlePrivateXtraErr(this.config as IImage)
                .then((newSrc) => {
                  imageUtils.imgLoadHandler(newSrc, (img) => {
                    if (imageUtils.getImgIdentifier(this.config.srcObj) === urlId) {
                      this.imgNaturalSize.width = img.width
                      this.imgNaturalSize.height = img.height
                      this.src = newSrc
                    }
                  })
                })
              return
            }

            reject(new Error(`cannot load the current image, src: ${this.src}`))
            this._onError(true)
          },
          crossOrigin: true
        })
      })
    },
    handleDimensionUpdate(newVal = 0 as number | string, oldVal = 0 as number | string) {
      if (this.config.srcObj.type === 'ios') return
      if (this.isBlurImg) return

      const currUrl = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, this.getImgDimension))
      if (!this.isOnError && currUrl) {
        const { type } = this.config.srcObj
        if (type === 'background') return
        const urlId = imageUtils.getImgIdentifier(this.config.srcObj)
        imageUtils.imgLoadHandler(currUrl, async () => {
          if (imageUtils.getImgIdentifier(this.config.srcObj) === urlId) {
            this.src = currUrl
            layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, { previewSrc: currUrl }, this.subLayerIndex)
            if (newVal > oldVal) {
              await this.preLoadImg('next', this.getImgDimension)
              this.preLoadImg('pre', this.getImgDimension)
            } else {
              await this.preLoadImg('pre', this.getImgDimension)
              this.preLoadImg('next', this.getImgDimension)
            }
          }
        }, {
          crossOrigin: true,
          error: () => {
            if (this.config.srcObj.type === 'private' && newVal === 'xtra') {
              imageUtils.handlePrivateXtraErr(this.config as IImage)
                .then((newSrc) => {
                  imageUtils.imgLoadHandler(newSrc, (img) => {
                    if (imageUtils.getImgIdentifier(this.config.srcObj) === urlId) {
                      this.imgNaturalSize.width = img.width
                      this.imgNaturalSize.height = img.height
                      this.src = newSrc
                    }
                  })
                })
            }
          }
        })
      }
    },
    async preLoadImg(preLoadType: 'pre' | 'next', val: number | string) {
      return new Promise<void>((resolve, reject) => {
        const size = imageUtils.getSrcSize(this.config.adjustSrcObj?.srcObj?.type ? this.config.adjustSrcObj?.srcObj : this.config.srcObj, val, preLoadType)
        const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, size))
        imageUtils.imgLoadHandler(src, () => resolve(), {
          error: () => {
            reject(new Error(`cannot preLoad the ${preLoadType}-image, src: ${src}`))
            fetch(src)
              .then(res => {
                const { status, statusText } = res
                this.logImgError('img src:', src, 'fetch result: ' + status + statusText)
              })
              .catch((e) => {
                this.logImgError('img src:', src, 'fetch result: ' + e)
              })
          },
          crossOrigin: true
        })
      })
    },
    handleIsTransparent(_img?: HTMLImageElement) {
      if (this.forRender || ['frame', 'tmp', 'group'].includes(this.primaryLayerType())) return

      const img = _img ?? this.$refs.img as HTMLImageElement
      if (!img) return

      const isTransparent = imageShadowUtils.isTransparentBg(img)
      imageShadowUtils.updateEffectProps(this.layerInfo(), { isTransparent })
      return isTransparent
    },
    async handleInitLoad() {
      if (this.userId !== 'backendRendering') {
        await this.previewAsLoading()
          .then((img) => {
            if (img) {
              this.handleIsTransparent(img)
            }
          })
      } else {
      // backendRendering DO NOT USE cross-origin
        const { imgWidth, imgHeight } = this.config.styles
        const srcSize = this.isBlurImg ? imageUtils.getSrcSize(this.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension
        const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.config, srcSize))
        if (this.isAdjustImage) {
          // adjust-image need to check if the image is transparent
          const tinyImg = imageUtils.appendQuery(imageUtils.getSrc(this.config.srcObj, imageUtils.getSrcSize(this.config.srcObj, 100)), 'ver', generalUtils.generateRandomString(4))
          await imageUtils.imgLoadHandler(tinyImg, (img) => this.handleIsTransparent(img), { crossOrigin: true })
        }
        imageUtils.imgLoadHandler(src, (img) => {
          this.imgNaturalSize.width = img.width
          this.imgNaturalSize.height = img.height
          this.src = src
        }, {
          crossOrigin: false,
          error: () => {
            this._onError()
        } })
      }
      this.initialized = true
    },
    handleShadowInit() {
      if (this.forRender) return
      const shadow = this.shadow()
      switch (shadow.srcObj.type) {
        case 'shadow-private':
          this.fetchShadowImg()
          break
        case 'upload':
          if (shadow.srcObj.assetId) {
            console.log('handle shadowInit: upload')
            this.handleUploadShadowImg()
          } else {
            console.log('handle shadowInit: upload')
            if (!this.isHandling && !this.isProcessing) {
              imageShadowUtils.updateEffectState(this.layerInfo(), ShadowEffectType.none)
            }
          }
          break
      }
    },
    handleUploadShadowImg() {
      const { srcObj } = this.shadow()
      if (srcObj.type === 'upload' && srcObj.assetId) {
        const uploadData = (this.uploadShadowImgs as Array<IUploadShadowImg>)
          .find((data: IUploadShadowImg) => data.id === srcObj.assetId)
        if (uploadData) {
          imageShadowUtils.updateShadowSrc(this.layerInfo(), uploadData.srcObj)
          imageShadowUtils.updateShadowStyles(this.layerInfo(), uploadData.styles)
        }
      }
    },
    async handleNewShadowEffect(clearShadowSrc = true) {
      const { layerInfo, shadowBuff } = this
      const canvas = this.$refs.canvas as HTMLCanvasElement

      if (!canvas || this.isUploadingShadowImg) {
        if (!canvas) {
          imageShadowUtils.setIsProcess(this.layerInfo(), false)
          imageShadowUtils.setProcessId()
          imageShadowUtils.setHandleId()
          console.warn('the canvas is undefined')
        }
        return
      }
      clearShadowSrc && this.clearShadowSrc()
      const { currentEffect } = this.shadow()
      const hasShadowSrc = this.shadow().srcObj.type && this.shadow().srcObj.type !== 'upload' && this.shadow().srcObj.assetId
      if (currentEffect !== ShadowEffectType.none) {
        imageShadowUtils.setProcessId(this.id())
        !hasShadowSrc && imageShadowUtils.setIsProcess(layerInfo(), true)
      }

      if (!['unsplash', 'pixels'].includes(this.config.srcObj.type) && !this.shadowBuff.MAXSIZE) {
        // normally, we should get the image size from srcObj, but if in vivisticker bg removing, we didn't actually upload the bg remove result to the server
        if ((this.config as IImage).srcObj.type === 'ios') {
          await imageUtils.imgLoadHandler(imageUtils.getSrc(this.config as IImage), (img) => {
            this.shadowBuff.MAXSIZE = Math.min(Math.max(img.naturalWidth, img.naturalHeight), CANVAS_MAX_SIZE)
          })
        } else {
          const res = await imageUtils.getImgSize(this.config.srcObj, false)
          if (res) {
            this.shadowBuff.MAXSIZE = Math.min(Math.max(res.data.height, res.data.width), CANVAS_MAX_SIZE)
          }
        }
      } else if (['unsplash', 'pixels'].includes(this.config.srcObj.type)) {
        this.shadowBuff.MAXSIZE = CANVAS_MAX_SIZE
      }

      let img
      switch (currentEffect) {
        case ShadowEffectType.imageMatched:
        case ShadowEffectType.floating:
        case ShadowEffectType.shadow:
        case ShadowEffectType.frame:
        case ShadowEffectType.blur: {
          if (!shadowBuff.canvasShadowImg) {
            /**
             * @Note need to review with steve
             */
            const src = imageUtils.getSrc(this.config, ['unsplash', 'pexels'].includes(this.config.srcObj.type) ? CANVAS_SIZE : 'smal')
            img = await imageUtils.imgLoadHandler(src, (_img) => _img, {
              error: (_img) => {
                console.log('img load error', _img?.src)
                notify({ group: 'copy', text: `${i18n.global.t('NN0351')}` })
              }
            }).then(async (_img) => {
              const isSVG = await imageShadowPanelUtils.isSVG(_img.src, this.config as IImage)
              if (isSVG) {
                await new Promise<void>((resolve)  => {
                  imageShadowPanelUtils.svgImageSizeFormatter(_img, 510, () => {
                    /** svgImageSizeFormatter change the img src, need to use onload to catch the changed img */
                    _img.onload = () => {
                      this.shadowBuff.MAXSIZE = CANVAS_MAX_SIZE
                      resolve()
                    }
                  })
                })
              }
              return _img
            })
            this.shadowBuff.canvasShadowImg = img
          } else {
            img = shadowBuff.canvasShadowImg as HTMLImageElement
          }
          break
        }
        case ShadowEffectType.none:
          imageShadowUtils.updateShadowSrc(this.layerInfo(), { type: '', assetId: '', userId: '' })
          imageShadowUtils.setProcessId()
          imageShadowUtils.clearLayerData()
          return
      }

      imageShadowUtils.updateEffectProps(this.layerInfo(), {
        maxsize: shadowBuff.MAXSIZE,
        middsize: Math.max(img.naturalWidth, img.naturalHeight)
      })

      /**
       * Check if the image is Transparent, only check as the isTransparent flag is undefined and false
       */
      if (typeof this.config.styles.shadow.isTransparent === 'undefined') {
        canvas.setAttribute('width', `${img.naturalWidth}`)
        canvas.setAttribute('height', `${img.naturalHeight}`)
        const ctx = canvas.getContext('2d') as CanvasRenderingContext2D
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, canvas.width, canvas.height)
        imageShadowUtils.updateEffectProps(layerInfo(), {
          isTransparent: imageShadowUtils.isTransparentBg(canvas)
        })
      }

      /**
       * Calculate canvas parameters
       */
      // small size preview
      const { width, height, imgWidth, imgHeight, shadow } = this.config.styles
      const _mappingScale = shadow.middsize / shadow.maxsize
      let _drawCanvasW = 0
      let _drawCanvasH = 0
      let _canvasW = 0
      let _canvasH = 0
      const isStaticShadow = currentEffect === ShadowEffectType.floating ||
        (!shadow.isTransparent && [ShadowEffectType.shadow, ShadowEffectType.frame, ShadowEffectType.blur].includes(shadow.currentEffect))
      if (isStaticShadow) {
        const ratio = currentEffect === ShadowEffectType.floating ? img.naturalWidth / img.naturalHeight : width / height
        _drawCanvasW = Math.round(ratio > 1 ? 1600 : 1600 * ratio)
        _drawCanvasH = Math.round(ratio > 1 ? 1600 / ratio : 1600)
        _canvasW = _drawCanvasW + CANVAS_SPACE
        _canvasH = _drawCanvasH + CANVAS_SPACE
      } else {
        _canvasW = img.naturalWidth + CANVAS_SPACE * _mappingScale
        _canvasH = img.naturalHeight + CANVAS_SPACE * _mappingScale
        _drawCanvasW = Math.round(img.naturalWidth * width / imgWidth)
        _drawCanvasH = Math.round(img.naturalHeight * height / imgHeight)
      }
      this.shadowBuff.canvasSize.width = _canvasW * width / _drawCanvasW
      this.shadowBuff.canvasSize.height = _canvasH * height / _drawCanvasH
      this.shadowBuff.drawCanvasW = _drawCanvasW
      this.shadowBuff.drawCanvasH = _drawCanvasH
      canvas.setAttribute('width', `${_canvasW}`)
      canvas.setAttribute('height', `${_canvasH}`)

      let canvasList = [canvas]
      if (this.isShowPagePanel) {
        const { pageIndex, layerIndex, subLayerIndex } = this
        canvasList = [
          ...document
            .querySelectorAll(`.shadow__canvas_${pageIndex}_${layerIndex}_${typeof subLayerIndex === 'undefined' ? -1 : subLayerIndex}`)
        ] as HTMLCanvasElement[]
      }

      const params = {
        pageId: this.page.id,
        drawCanvasW: _drawCanvasW,
        drawCanvasH: _drawCanvasH,
        layerInfo: layerInfo(),
        cb: () => {
          if (this.config.styles.shadow.cb) {
            this.config.styles.shadow.cb()
            this.$store.commit('SET_shadowCallback', { layerInfo: this.layerInfo(), cb: undefined })
          }
          this.clearShadowSrc()
        }
      }
      imageShadowUtils.drawingInit(canvas, img, this.config as IImage, params)
      switch (currentEffect) {
        case ShadowEffectType.shadow:
        case ShadowEffectType.frame:
        case ShadowEffectType.blur:
          imageShadowUtils.drawShadow(canvasList, this.config as IImage, params)
          break
        case ShadowEffectType.imageMatched:
          imageShadowUtils.drawImageMatchedShadow(canvasList, img, this.config as IImage, params)
          break
        case ShadowEffectType.floating: {
          imageShadowUtils.drawFloatingShadow(canvasList, this.config as IImage, params)
          break
        }
      }
    },
    updateShadowEffect(effects: IShadowEffects) {
      const { shadowBuff } = this
      const canvas = this.$refs.canvas as HTMLCanvasElement
      const layerInfo = this.layerInfo()
      const { drawCanvasW, drawCanvasH } = shadowBuff
      if (!canvas || this.isUploadingShadowImg) {
        console.log('can not get canvas')
        return
      }

      let canvasList = [canvas]
      if (this.isShowPagePanel) {
        const { pageIndex, layerIndex, subLayerIndex } = this
        canvasList = [
          ...document
            .querySelectorAll(`.shadow__canvas_${pageIndex}_${layerIndex}_${typeof subLayerIndex === 'undefined' ? -1 : subLayerIndex}`)
        ] as HTMLCanvasElement[]
      }

      window.requestAnimationFrame(() => {
        this.UPDATE_shadowEffect({
          layerInfo,
          payload: {
            ...effects
          }
        })
        switch (this.currentShadowEffect()) {
          case ShadowEffectType.shadow:
          case ShadowEffectType.blur:
          case ShadowEffectType.frame:
            if (shadowBuff.canvasShadowImg as HTMLImageElement) {
              imageShadowUtils.drawShadow(canvasList, this.config as IImage, {
                layerInfo,
                drawCanvasW,
                drawCanvasH,
                cb: () => this.shadow().srcObj.type && this.clearShadowSrc()
              })
            }
            break
          case ShadowEffectType.imageMatched:
            if (shadowBuff.canvasShadowImg as HTMLImageElement) {
              imageShadowUtils.drawImageMatchedShadow(canvasList, shadowBuff.canvasShadowImg as HTMLImageElement, this.config as IImage, {
                layerInfo,
                drawCanvasW,
                drawCanvasH,
                cb: () => this.shadow().srcObj.type && this.clearShadowSrc()
              })
            }
            break
          case ShadowEffectType.floating:
            if (shadowBuff.canvasShadowImg as HTMLImageElement) {
              imageShadowUtils.drawFloatingShadow(canvasList, this.config as IImage, {
                layerInfo,
                drawCanvasW,
                drawCanvasH,
                cb: () => this.shadow().srcObj.type && this.clearShadowSrc()
              })
            }
            break
          case ShadowEffectType.none:
            break
          default:
            generalUtils.assertUnreachable(this.currentShadowEffect() as never)
        }
      })
    },
    clearShadowSrc() {
      if (this.handleId.pageId && this.handleId.layerId) {
        imageShadowUtils.updateShadowSrc(this.layerInfo(), { type: '', assetId: '', userId: '' })
      }
    },
    redrawShadow() {
      const id = {
        pageId: this.page.id,
        layerId: typeof this.layerIndex !== 'undefined' && this.layerIndex !== -1
          ? layerUtils.getLayer(this.pageIndex, this.layerIndex).id : this.config.id,
        subLayerId: this.config.id
      }
      imageShadowUtils.setHandleId(id)
      imageShadowUtils.updateShadowSrc(this.layerInfo(), { type: '', assetId: '', userId: '' })
      layerUtils.updateLayerStyles(this.pageIndex, this.layerIndex, { scale: 1 }, this.subLayerIndex)
      groupUtils.deselect()
      if (!this.isShowPagePreview) {
        groupUtils.select(this.pageIndex, [this.layerIndex])
      }
      if (typeof this.subLayerIndex && this.subLayerIndex !== -1) {
        layerUtils.updateLayerProps(this.pageIndex, this.layerIndex, { active: true }, this.subLayerIndex)
      }
      this.$nextTick(() => {
        const primarylayerId = layerUtils.getLayer(this.layerInfo().pageIndex, this.layerInfo().layerIndex).id
        const layerData = {
          primarylayerId,
          config: this.config,
          layerInfo: this.layerInfo
        }
        imageShadowPanelUtils.handleShadowUpload(layerData)
      })
    },
    fetchShadowImg() {
      const { assetId } = (this.config as IImage).styles.shadow.srcObj
      const shadowImgs = (this.$store.getters['shadow/shadowImgs'] as Map<number, IShadowAsset>)
      if (typeof assetId === 'number') {
        if (!shadowImgs.has(assetId)) {
          this.$store.dispatch('shadow/ADD_SHADOW_IMG', [assetId])
            .then(() => {
              imageShadowUtils.updateShadowSrc(this.layerInfo(), {
                ...(this.config as IImage).styles.shadow.srcObj,
                // only used to make Vue update the value, this userId is not meaningful
                userId: 'ver=' + generalUtils.generateRandomString(8)
              })
            })
        }
      }
    },
    layerInfo(): ILayerInfo {
      const layerInfo = {
        pageIndex: this.pageIndex,
        layerIndex: this.layerIndex,
        subLayerIdx: this.subLayerIndex
      }
      return layerInfo
    },
    scaledConfig(): { [index: string]: string | number } {
      const { width, height, imgWidth, imgHeight, imgX, imgY } = this.config.styles as IImageStyle
      const _f = this.contentScaleRatio * (this.primaryLayer?.type === 'frame' || !this.$isTouchDevice() ? 1 : this.pageScaleRatio * 0.01)
      return {
        width: width * _f,
        height: height * _f,
        imgWidth: imgWidth * _f,
        imgHeight: imgHeight * _f,
        imgX: imgX * _f,
        imgY: imgY * _f
      }
    },
    cssFilterElms() {
      const { adjust, width, height } = this.adjustImgStyles()
      // @TODO: only for halation now
      if (Number.isNaN(adjust.halation) || !adjust.halation) {
        return []
      }
      const _f = this.contentScaleRatio * (this.$isTouchDevice() ? this.pageScaleRatio * 0.01 : 1)

      const position = {
        width: width / 2 * _f,
        x: width / 2 * _f,
        y: height / 2 * _f
      }
      return imageAdjustUtil.getHalation(adjust.halation, position)
    },
    svgFilterElms() {
      const { adjust } = this.adjustImgStyles()
      return imageAdjustUtil.convertAdjustToSvgFilter(adjust || {}, this.config as IImage)
    },
    imgStyles() {
      let { imgX, imgY, imgHeight, imgWidth } = this.scaledConfig()
      if (this.isBgImgControl) {
        imgX = 0
        imgY = 0
      }
      return {
        transform: `translate(${imgX}px, ${imgY}px)`,
        width: `${imgWidth}px`,
        height: `${imgHeight}px`
      }
    },
    getPreviewSize(): number | string {
      const sizeMap = this.imgSizeMap as Array<{ [key: string]: number | string }>
      return imageUtils
        .getSrcSize(this.config.srcObj, sizeMap?.flatMap(e => e.key === 'tiny' ? [e.size] : [])[0] as number || 320)
    },
    hasHalation(): boolean {
      return this.config.styles.adjust?.halation
    },
    adjustImgStyles() {
      let styles = this.config.styles
      if (this.isBgImgControl) {
        styles = generalUtils.deepCopy(this.config.styles)
        Object.assign(styles.adjust, {
          halation: 0
        })
      }
      return styles
    },
    flippedAnimation(): boolean {
      const primaryLayer = layerUtils.getLayer(this.pageIndex, this.layerIndex)
      if (typeof this.subLayerIndex !== 'undefined' && this.subLayerIndex !== -1 && primaryLayer.type === 'frame') {
        return false
      } else {
        return true
      }
    },
    shadow(): IShadowProps {
      return (this.config as IImage).styles.shadow
    },
    currentShadowEffect(): ShadowEffectType {
      return this.shadow().currentEffect
    },
    primaryLayerType(): string {
      if (this.prePrimaryLayerIndex === -1) {
        return layerUtils.getLayer(this.pageIndex, this.layerIndex).type
      } else {
        return (layerUtils.getLayer(this.pageIndex, this.prePrimaryLayerIndex) as IGroup).layers[this.layerIndex].type
      }
    },
    id(): ILayerIdentifier {
      return {
        pageId: this.page.id,
        layerId: typeof this.layerIndex !== 'undefined' && this.layerIndex !== -1
          ? layerUtils.getLayer(this.pageIndex, this.layerIndex).id : this.config.id,
        subLayerId: this.config.id
      }
    }
  }
})
</script>

<style lang="scss" scoped>
.nu-image {
  width: 100%;
  height: 100%;

  &__shadow-container {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  &__clipper {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }

  &__img {
    object-fit: cover;
    display: block;
  }

  &__picture {
    touch-action: none;
    -webkit-touch-callout: none;
    user-select: none;
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
  }

  &__picture-shadow {
    touch-action: none;
    -webkit-touch-callout: none;
    user-select: none;
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
  }

  &__svg {
    display: block;
    position: absolute;
    top: 0;
  }

  &__adjust {
    pointer-events: none;
  }
}

.shadow {
  &__canvas-wrapper {
    position: absolute;
    pointer-events: none;
    flex-shrink: 0;
  }
  &__picture {
    position: absolute;
    pointer-events: none;
  }
}

canvas {
  width: 100%;
  height: 100%;
}
</style>
