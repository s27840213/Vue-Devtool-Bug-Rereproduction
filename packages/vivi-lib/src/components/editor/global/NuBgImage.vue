<template lang="pug">
div(v-if="!isBgCtrlImgLoaded" class="nu-background-image" draggable="false" :style="mainStyles"  @click="setInBgSettingMode" @tap="dblTap")
  div(v-show="!isColorBackground" class="nu-background-image__image" :style="imgStyles")
    img(v-show="!isAdjustImage" ref="img"
        crossorigin="anonymous"
        draggable="false"
        @error="onError"
        @load="onLoad"
        :src="finalSrc")
    svg(v-if="isAdjustImage"
      class="nu-background-image__svg"
      :viewBox="`0 0 ${imgNaturalSize.width} ${imgNaturalSize.height}`"
      preserveAspectRatio="none"
      role="image")
      defs
        filter(:id="filterId"
          color-interpolation-filters="sRGB")
          component(v-for="(elm, idx) in svgFilterElms"
            :key="`${filterId + idx}`"
            :is="elm.tag"
            v-bind="elm.attrs")
            component(v-for="child in elm.child"
              :key="child.tag"
              :is="child.tag"
              v-bind="child.attrs")
      image(ref="adjust-img"
        crossorigin="anonymous"
        class="nu-background-image__adjust-image"
        :filter="`url(#${filterId})`"
        :width="imgNaturalSize.width"
        :height="imgNaturalSize.height"
        @error="onError"
        @load="onAdjustImgLoad"
        :xlink:href="finalSrc" )
  div(:style="filterContainerStyles()" class="filter-container")
    component(v-for="(elm, idx) in cssFilterElms"
      :key="`cssFilter${idx}`"
      :is="elm.tag"
      v-bind="elm.attrs")
</template>

<script lang="ts">
import { SrcObj } from '@/interfaces/gallery'
import { IImage } from '@/interfaces/layer'
import { IPage } from '@/interfaces/page'
import { IBrowserInfo } from '@/store/module/user'
import cssConverter from '@/utils/cssConverter'
import doubleTapUtils from '@/utils/doubleTapUtils'
import editorUtils from '@/utils/editorUtils'
import generalUtils from '@/utils/generalUtils'
import groupUtils from '@/utils/groupUtils'
import imageAdjustUtil from '@/utils/imageAdjustUtil'
import imageShadowUtils from '@/utils/imageShadowUtils'
import imageUtils from '@/utils/imageUtils'
import logUtils from '@/utils/logUtils'
import pageUtils from '@/utils/pageUtils'
import { AxiosError } from 'axios'
import { PropType, defineComponent } from 'vue'
import { mapActions, mapGetters, mapMutations, mapState } from 'vuex'
import NuAdjustImage from './NuAdjustImage.vue'
import stkWVUtils from '@/utils/stkWVUtils'
import i18n from '@/i18n'
import modalUtils from '@/utils/modalUtils'
import backgroundUtils from '@/utils/backgroundUtils'

export default defineComponent({
  emits: [],
  props: {
    image: {
      type: Object,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    pageIndex: {
      type: Number,
      required: true
    },
    page: {
      type: Object as PropType<IPage>,
      required: true
    },
    contentScaleRatio: {
      default: 1,
      type: Number
    },
    padding: {
      type: String,
      default: '0'
    }
  },
  data() {
    return {
      src: '',
      imgNaturalSize: {
        width: 0,
        height: 0
      },
      errorSrcIdentifier: { identifier: '', retry: 0 },
    }
  },
  watch: {
    srcObj: {
      deep: true,
      handler: function () {
        if (this.isColorBackground) {
          this.src = ''
        } else {
          this.previewAsLoading()
            .then((img) => this.handleIsTransparent(img))
        }
      }
    },
    getImgDimension(newVal, oldVal) {
      this.handleDimensionUpdate(newVal, oldVal)
    },
    'image.config.imgControl'(val) {
      if (val) {
        this.setBgImgConfig(this.pageIndex)
      } else {
        this.setBgImgConfig(undefined)
      }
    },
    isBlurImg(val) {
      const { imgWidth, imgHeight } = this.image.config.styles
      const src = imageUtils.getSrc(this.image.config, val ? imageUtils.getSrcSize(this.image.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension)
      imageUtils.imgLoadHandler(src, () => {
        // bcz this is an async operation, need to check if isBlurImg is the same val
        if (this.isBlurImg === val) {
          this.src = src
        }
      }, { crossOrigin: true })
    }
  },
  async created() {
    const { srcObj } = this
    if (!srcObj || !srcObj.type) return

    const { assetId } = this.image.config.srcObj
    if (srcObj.type === 'private') {
      const editorImg = this.getEditorViewImages
      if (!editorImg(assetId)) {
        await this.updateImages({ assetSet: new Set<string>([assetId]) })
      }
    }

    if (this.userId !== 'backendRendering') {
      this.previewAsLoading()
        .then((img) => this.handleIsTransparent(img))
    } else {
      const { imgWidth, imgHeight } = this.image.config.styles
      const src = imageUtils.getSrc(this.image.config, this.isBlurImg ? imageUtils.getSrcSize(this.image.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension)
      if (this.isAdjustImage) {
        imageUtils.imgLoadHandler(src, (img) => {
          this.handleIsTransparent(img)
          this.src = src
        }, { crossOrigin: true })
      } else {
        this.src = src
      }
    }
  },
  components: { NuAdjustImage },
  computed: {
    ...mapGetters({
      scaleRatio: 'getPageScaleRatio',
      getEditorViewImages: 'file/getEditorViewImages',
      imgControlPageIdx: 'imgControl/imgControlPageIdx',
      isBgImgCtrl: 'imgControl/isBgImgCtrl',
      isBgCtrlImgLoaded: 'imgControl/isBgCtrlImgLoaded',
    }),
    ...mapState('mobileEditor', {
      inAllPagesMode: 'mobileAllPageMode',
    }),
    ...mapState('user', ['imgSizeMap', 'userId']),
    imgStyles(): Record<string, string> {
      return this.stylesConverter()
    },
    finalSrc(): string {
      if (this.$route.name === 'Preview') {
        return imageUtils.appendCompQueryForVivipic(this.src)
      }
      return this.src
    },
    isColorBackground(): boolean {
      const { srcObj } = this.image.config
      return !srcObj || srcObj.assetId === ''
    },
    getImgDimension(): number | string {
      const { srcObj, styles: { imgWidth, imgHeight } } = this.image.config as IImage
      let renderW = imgWidth * this.contentScaleRatio
      let renderH = imgHeight * this.contentScaleRatio
      const dpiRatio = pageUtils.getImageDpiRatio(this.page)
      renderW *= dpiRatio
      renderH *= dpiRatio
      return imageUtils.getSrcSize(srcObj, Math.max(renderW, renderH) * (this.scaleRatio / 100))
    },
    pageSize(): { width: number, height: number, physicalWidth: number, physicalHeight: number, unit: string } {
      return pageUtils.removeBleedsFromPageSize(this.page)
    },
    srcObj(): SrcObj {
      return this.image.config.srcObj
    },
    flipStyles(): { transform: any } {
      const { horizontalFlip, verticalFlip } = this.image.config.styles
      return cssConverter.convertFlipStyle(horizontalFlip, verticalFlip)
    },
    imageSize(): { width: number, height: number, x: number, y: number } {
      const { image } = this
      const offset = this.$isStk ? 0 : 1 // no need to scale bg image in vivisticker
      const aspectRatio = image.config.styles.imgWidth / image.config.styles.imgHeight
      const width = image.config.styles.imgWidth + (aspectRatio < 1 ? offset * 2 : offset * 2 * aspectRatio)
      const height = image.config.styles.imgHeight + (aspectRatio > 1 ? offset * 2 : offset * 2 / aspectRatio)
      const x = image.posX - (aspectRatio < 1 ? offset : offset * aspectRatio)
      const y = image.posY - (aspectRatio > 1 ? offset : offset / aspectRatio)
      const _f = this.contentScaleRatio * (this.$isTouchDevice() ? this.scaleRatio * 0.01 : 1)
      return {
        width: width * _f,
        height: height * _f,
        x: x * _f,
        y: y * _f
      }
    },
    mainStyles(): any {
      return {
        ...(this.isAdjustImage && !this.inAllPagesMode && { transform: 'translateZ(0)' }),
        margin: this.padding.split(' ').map(val => '-' + val).join(' '),
        padding: this.padding,
        opacity: this.image.config.styles.opacity / 100,
        backgroundColor: this.color
      }
    },
    isAdjustImage(): boolean {
      const { styles } = this.image.config
      const entries = Object
        .entries(styles.adjust || {})
        .filter(([, val]) => typeof val === 'number' && val !== 0)
      return entries.length > 1 || (entries.length === 1 && entries[0][0] !== 'halation')
    },
    cssFilterElms(): any[] {
      const { adjust } = this.image.config.styles
      const { width, height } = this.pageSize
      if (!adjust) return []

      const elms = []
      if (adjust.halation) {
        const _f = this.contentScaleRatio * (this.$isTouchDevice() ? this.scaleRatio * 0.01 : 1)
        const position = {
          width: width / 2 * _f,
          x: width / 2 * _f,
          y: height / 2 * _f
        }
        elms.push(...imageAdjustUtil.getHalation(adjust.halation, position))
      }
      return elms
    },
    svgFilterElms(): any[] {
      const { adjust } = this.image.config.styles
      return imageAdjustUtil.convertAdjustToSvgFilter(adjust || {}, { styles: this.image.config.styles } as IImage)
    },
    filterId(): string {
      const browserInfo = this.$store.getters['user/getBrowserInfo'] as IBrowserInfo
      const browserIsSafari = browserInfo.name === 'Safari' && browserInfo.version !== '16.3' && generalUtils.versionCheck({ greaterThan: '16.0', lessThan: '16.3' })
      const osIsIos = browserInfo.os.family === 'iOS' && browserInfo.os.version !== '16.3' && generalUtils.versionCheck({ greaterThan: '16.0', lessThan: '16.3', version: browserInfo.os.version })
      if (browserIsSafari || osIsIos) {
        const { styles: { adjust }, id: layerId } = this.image.config
        const { blur = 0, brightness = 0, contrast = 0, halation = 0, hue = 0, saturate = 0, warm = 0 } = adjust
        const id = layerId + blur.toString() + brightness.toString() + contrast.toString() + halation.toString() + hue.toString() + saturate.toString() + warm.toString()
        return `filter__${id}`
      } else {
        const randomId = generalUtils.generateRandomString(5)
        return `filter__${randomId}`
      }
    },
    isBlurImg(): boolean {
      return !!this.image.config.styles.adjust?.blur
    }
  },
  methods: {
    ...mapActions('file', ['updateImages']),
    ...mapActions('brandkit', ['updateLogos']),
    ...mapMutations({
      setBgImageSrc: 'SET_backgroundImageSrc',
      setBgImgConfig: 'imgControl/SET_BG_CONFIG',
      setBgImageControl: 'SET_backgroundImageControl'
    }),
    getErrorSrcIdentifier(config: IImage) {
      const { srcObj, styles } = config
      return srcObj.type + srcObj.assetId + srcObj.userId + (styles.adjust.blur > 0 ? '_blur' : '')
    },
    onError() {
      this._onError()
    },
    _onError(imgLoadHandlerError = false) {
      if (!this.src && !imgLoadHandlerError) return
      if (this.errorSrcIdentifier.identifier === this.getErrorSrcIdentifier(this.image.config as IImage)) {
        if (this.errorSrcIdentifier.retry === 3) {
          return
        }
        this.errorSrcIdentifier.retry++
      } else {
        this.errorSrcIdentifier.identifier = this.getErrorSrcIdentifier(this.image.config as IImage)
        this.errorSrcIdentifier.retry = 1
      }

      const srcObj = this.image.config.srcObj
      let updater
      switch (srcObj.type) {
        case 'private':
          updater = async () => await this.updateImages({ assetSet: new Set<string>([this.image.config.srcObj.assetId]) })
          break
        case 'logo-private':
          updater = async () => await this.updateLogos({ assetSet: new Set<string>([this.image.config.srcObj.assetId]) })
          break
        case 'ios': {
          // replace error image
          this.$store.commit('SET_backgroundImageSrc', {
            pageIndex: this.pageIndex,
            srcObj: {
              type: '',
              userId: '',
              assetId: ''
            },
            previewSrc: ''
          })
          this.src = ''
          stkWVUtils.setLoadingFlag(-1)
          const modalBtn = {
            msg: i18n.global.t('STK0023') as string,
          }
          modalUtils.setModalInfo(i18n.global.t('STK0024') as string, i18n.global.t('STK0086') as string, modalBtn)
        }
      }

      if (updater !== undefined) {
        try {
          updater().then(() => {
            const { imgWidth, imgHeight } = this.image.config.styles
            const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, this.isBlurImg ? Math.max(imgWidth, imgHeight) : this.getImgDimension))
            imageUtils.imgLoadHandler(src, () => {
              this.src = src
            }, { crossOrigin: true })
          })
        } catch (error) {
          if (this.src.indexOf('data:image/png;base64') !== 0) {
            fetch(this.src)
              .then(res => {
                const { status, statusText } = res
                this.logImgError(error, 'fetch result: ' + status + statusText)
              })
              .catch((e) => {
                this.logImgError(error, 'fetch result: ' + e)
              })
          }
        }
      }
    },
    dblTap(e: PointerEvent) {
      this.setInBgSettingMode()
      doubleTapUtils.click(e, {
        doubleClickCallback: () => {
          if (this.image.config.srcObj.type) {
            if (backgroundUtils.backgroundLocked) return backgroundUtils.handleLockedNotify()
            this.setBgImageControl({
              pageIndex: this.pageIndex,
              imgControl: true
            })
            editorUtils.setCurrActivePanel('crop')
          }
        }
      })
    },
    handleIsTransparent(img? : HTMLImageElement) {
      if (!this.$refs.img) return

      this.$store.commit('SET_backgroundImageStyles', {
        pageIndex: this.pageIndex,
        styles: {
          shadow: {
            isTransparent: imageShadowUtils.isTransparentBg(img ?? this.$refs.img as HTMLImageElement)
          }
        }
      })
    },
    filterContainerStyles() {
      return { margin: this.padding }
    },
    async previewAsLoading(): Promise<HTMLImageElement | undefined> {
      let isPrimaryImgLoaded = false
      const config = this.image.config as IImage
      const urlId = imageUtils.getImgIdentifier(this.image.config.srcObj)
      let preImg
      if (config.previewSrc) {
        const previewSrc = config.previewSrc
        preImg = await imageUtils.imgLoadHandler(previewSrc, (img) => {
          if (imageUtils.getImgIdentifier(this.image.config.srcObj) === urlId && !isPrimaryImgLoaded) {
            this.src = previewSrc
            return img
          }
        }, { crossOrigin: true })
          .catch(() => {
            if (src === config.previewSrc) {
              this._onError(true)
            }
            console.warn('bg-img preview cannot be loaded!')
          })
      }
      const { imgWidth, imgHeight } = this.image.config.styles
      const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, this.isBlurImg ? imageUtils.getSrcSize(this.image.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension))
      if (!src || src === config.previewSrc) return preImg as HTMLImageElement | undefined

      return new Promise<HTMLImageElement | undefined>((resolve, reject) => {
        imageUtils.imgLoadHandler(src, (img) => {
          if (imageUtils.getImgIdentifier(this.image.config.srcObj) === urlId) {
            isPrimaryImgLoaded = true
            this.src = src
            if (!this.isBlurImg) {
              this.preLoadImg('pre', this.getImgDimension)
              this.preLoadImg('next', this.getImgDimension)
            }
            resolve(img)
          }
        }, {
          error: (img) => {
            if (imageUtils.handlePrivateXtraErr(this.image.config, img)) {
              const newSrc = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, this.isBlurImg ? imageUtils.getSrcSize(this.image.config.srcObj, Math.max(imgWidth, imgHeight)) : this.getImgDimension))
              imageUtils.imgLoadHandler(newSrc, (img) => {
                if (imageUtils.getImgIdentifier(this.image.config.srcObj) === urlId) {
                  this.src = newSrc
                  this.imgNaturalSize.width = img.width
                  this.imgNaturalSize.height = img.height
                }
              })
              return
            }

            reject(new Error(`cannot load the current image, src: ${src}`))
            this._onError(true)
          },
          crossOrigin: true
        })
      })
    },
    stylesConverter(): { [key: string]: string } {
      return {
        width: `${this.imageSize.width}px`,
        height: `${this.imageSize.height}px`,
        transform: `translate(${this.imageSize.x}px, ${this.imageSize.y}px) ${this.flipStyles.transform}`
      }
    },
    setInBgSettingMode() {
      editorUtils.setInBgSettingMode(true)
      groupUtils.deselect()
    },
    handleDimensionUpdate(newVal: number | string, oldVal: number) {
      if (this.isBlurImg) return

      const currUrl = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, newVal))
      if (currUrl) {
        const urlId = imageUtils.getImgIdentifier(this.image.config.srcObj)
        imageUtils.imgLoadHandler(currUrl, async () => {
          if (imageUtils.getImgIdentifier(this.image.config.srcObj) === urlId) {
            this.src = currUrl
            // @TODO considering string case
            if (typeof newVal === 'number' && typeof oldVal === 'number' && newVal > oldVal) {
              await this.preLoadImg('next', newVal)
              this.preLoadImg('pre', newVal)
            } else {
              await this.preLoadImg('pre', newVal)
              this.preLoadImg('next', newVal)
            }
          }
        }, {
          crossOrigin: true,
          error: (img) => {
            if (imageUtils.handlePrivateXtraErr(this.image.config, img)) {
              const newSrc = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, newVal))
              imageUtils.imgLoadHandler(newSrc, (img) => {
                if (imageUtils.getImgIdentifier(this.image.config.srcObj) === urlId) {
                  this.src = newSrc
                  this.imgNaturalSize.width = img.width
                  this.imgNaturalSize.height = img.height
                }
              })
            }
          }
        })
      }
    },
    logImgError(error: unknown, ...infos: Array<string>) {
      if (this.src.indexOf('data:image/png;base64') !== 0) return
      const { srcObj: { type, assetId, userId } } = this.image.config as IImage
      const e = error as Error | AxiosError
      let log =
        'bg-image error' +
        `srcObj: { type: ${type}, assetId: ${assetId}, userId: ${userId} }\n` +
        `Error config src: ${this.src}`
      infos.forEach(info => { log += `\n${info}` })
      console.warn(log)
      logUtils.setLog(log)
    },
    async preLoadImg(preLoadType: 'pre' | 'next', val: number | string) {
      return new Promise<void>((resolve, reject) => {
        const size = imageUtils.getSrcSize(this.image.config.adjustSrcObj?.srcObj?.type ? this.image.config.adjustSrcObj?.srcObj : this.image.config.srcObj, val, preLoadType)
        const src = imageUtils.appendOriginQuery(imageUtils.getSrc(this.image.config, size))
        imageUtils.imgLoadHandler(src, () => resolve(), {
          error: () => {
            reject(new Error(`cannot preLoad the ${preLoadType}-image`))
            fetch(src)
              .then(res => {
                const { status, statusText } = res
                this.logImgError('img src:', src, 'fetch result: ' + status + statusText)
              })
              .catch((e) => {
                this.logImgError('img src:', src, 'fetch result: ' + e)
              })
          },
          crossOrigin: true
        })
      })
    },
    onAdjustImgLoad(e: Event) {
      imageUtils.imgLoadHandler(this.src, (img) => {
        if (this.imgNaturalSize.width !== img.width || this.imgNaturalSize.height !== img.height) {
          this.imgNaturalSize.width = img.width
          this.imgNaturalSize.height = img.height
        }
      }, { crossOrigin: true })
      if (this.$isStk) {
        // detect if SVG image rendered
        const rendering = () => {
          const elImg = this.$refs['adjust-img'] as SVGImageElement
          if (!elImg) return
          if (elImg.width.baseVal.value || elImg.height.baseVal.value) {
            // Render complete
            stkWVUtils.setLoadingFlag(-1)
          } else {
            // Rendering
            window.requestAnimationFrame(rendering)
          }
        }
        window.requestAnimationFrame(rendering)
      }
    },
    onLoad(e: Event) {
      const img = e.target as HTMLImageElement
      if (this.imgNaturalSize.width !== img.width || this.imgNaturalSize.height !== img.height) {
        this.imgNaturalSize.width = img.width
        this.imgNaturalSize.height = img.height
      }
      if (this.$isStk) {
        stkWVUtils.setLoadingFlag(-1)
      }
    }
  }
})
</script>

<style lang="scss" scoped>
.nu-background-image {
  position: absolute;
  // width: 100%;
  // height: 100%;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  @include stk {
    border-radius: 10px;
  }
  &__picture {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  text-align: left;

  &__color {
    position: relative;
    width: 100%;
    height: 100%;
  }

  &__image{
    position: relative;
    >img {
      position: absolute;
      width: 100%;
      height: 100%;
    }
  }

  &__adjust-image {
    // will-change: contents;
  }

  &__svg {
    display: block;
    height: 100%;
    position: absolute;
    width: 100%;
  }
}

.body {
  transition: opacity 1s;
}

.filter-container {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
</style>
